
In this section, we will present how we implemented everything. The
presentation will be done class by class. All the functions that are
prefixed by an underscore should never be used by the user (for example
\verb!_popNext! or \verb!_setup!). These functions are auxilliary functions
that are used by the simulation to generate the data. This convention follows
the PEP8 convention of python, as python does not give a way to protect
methods.

\subsection{Timestamp}

The Timestamp object has many features. We based our implementation on the
\verb!datetime! and \verb!dateutil! Python packages. They provide base
operations and functions on time and dates. The Timestamp class is a simple
wrapper around these packages. The major modification is the overloading of the
different operators. In order to provide a user-friendly interface, we
overloaded the operators to allow comparison, addition, substraction with
strings. For example, one can write \verb!t2 = t1 + "2h45m"!. We found a simple
parser to use this kind of notations.

\subsection{Data}

The Data object is a simple dictionnary. It must have three informations :
\verb!timestamp!, \verb!sensor!, \verb!value!. Then, all additionnal field is
added to the \verb!__dict__! attribute.
This way, the sensors can put all kind of information in the Data object.

\subsection{Simulation}

The Simulation works in three phases :
\begin{itemize}
    \item Setup : Sets all internal parameters, calls \verb!_setup()! on all
sensors and displays, sets the start and stop time of the simulation
    \item Run : A simple loop : while there is still data to get and we are
before the stop time, pop the next Data.
    \item Stop : When the simulation ends, close the displays.
\end{itemize}

\subsection{Sensors}

The main class that need to be understood first is the class of the
sensors. The idea is to have sensors defined by different manners that will
behave the same way. For example, from the simulation class, it will be
impossible to know if a data comes from data imported from a file, or from
a Markov Chain. The Sensor class is an abstract class that will define the
functions that need to be implemented in order to get this behaviour.

\subsubsection{The Sensor abstract class}

The main implementation choice that was made was the one to know how we would
generate the data, and send it to the simulation. This is done using a method
\verb!_popNext! that will return the next data generated by the sensor. The
associated function is \verb!_getNext! that will return the next data that will
be generated, but this data is not meant to be used right now (the data can be
used to know beforehand when will be the next data generated).

Each sensor must also implement a \verb!_advanceTime! function, called after a
\verb!_popNext!, this moves the sensor inner clock to the next data that will
be returned

Above that, a sensor has a \verb!name! attribute, with the associated setter
(\verb!setName!). If the name is not defined by the user, it will be generated
automatically as ``Sensor\_i'' where $i$ will be incremented each time a new
name is defined (to prevent from two sensors with the same name).

Now we should look deeper into the different classes that will inherit from the
Sensor class

\subsubsection{The modelSensor abstract class}

This class is an abstract class that represents a sensor modelled by some
law. For example, the user may want to define a sensor that will behave like a
Markov Chain, or a like a given function. The inherited class will represent a
different model. There is an attribute defined by the modelSensor class that is
the step of the created sensor. The step attribute will define at which speed
the sensor will send data (for example, a computer energy consumption can be
received each millisecond, whereas sensor from a parking lot will only send
data every second, or minute).

\paragraph{Markov Chains}

One model that is implemented is the one of Markov Chains. The state returned
by the sensor is following the low of a Markov Chain. To define a Markov
Chain, the user need to define the nodes, the transitions and the starting
node. The nodes can be named with integers or strings or any type, and it is these names that will be returned as the value of the sensor.
Setting the transition is harder: the implementation choosed to give a method
\verb!addTransition(node1, node2, proba)!. The user has to define all the
values of the transitions (the initial probability is 0).

We are working with probabilities, and then the sum of the probabilities of transition should sum up to one.
We enforce this fact by not looking at the last transition for each node, because we know that it is one minus the sum of the other probabilities. This way, we prevent the user from defining bad transitions, and locking the simulation.

\paragraph{FunctionSensor class}

This class will also behave like a sensor, but will generate data from a given
function. The function is an attribute of the instance of the class, and there
is the setter associated to it.

\subparagraph{Polynomial sensor}

A special type of FunctionSensor. It implements a polynomial function of
the time. It can be built from a polynomial, a set of coefficients or a set
of points from which we interpolate the polynomial. See previous section for
useage.

\paragraph{Masked Sensor}

A Wrapper around a sensor. Calls the sub-sensor, but forwards its data only if
the timestamp is in in a valid segment.

\paragraph{Speed Sensor}

A Wrapper around a sensor. Calls the sub-sensor, and scales the timestamp of
the returned data. This way, it acts as if the sub-sensor runds at a different
speed.

\subsubsection{The Importer abstract class}

The importer class is also an abstract class that implements the function
to read text from an input file, and the functions to get the next data
(\verb!_popNext! and \verb!_getNext!). The user have to define a filename
at the creation of the class. The real importation of the data (depending
on the type of storage of the data) is done in inherited classes, during the
setup phase. During this phase, the inherited classes will have to store the
data in the attribute \verb!data!, in a \verb!deque! (which is a list where we can pop the first element in constant time), where the timestamps are sorted in increasing order. Then the methods
\verb!_popNext! and \verb!_getNext! will do the interface with the simulation
(by popping data from the \verb!deque!).

\paragraph{The JsonImporter class}

To import a JSON file, we need to know what
will be the attributes of the main dictionnary. I use
\href{https://github.com/SINTEF-9012/sensapp/tree/master/net.modelbased.sensapp.data.samples/CyclingData}{this format}, as it is suggested in the subject of the project. We suppose that:

\begin{itemize}
\item the main data is a dictionary
\item there is a key \verb!"bn"! and the value is the name of the sensor
\item there is a key \verb!"e"! and the value is the data, as a list of dictionaries, one for each data
\item each data is a dictionary with:
      \begin{itemize}
      \item a key \verb!"t"! and the value is the timestamp
      \item a key \verb!"v"! and the value is the data of the sensor
      \end{itemize}
\end{itemize}

This assumptions are done to be able to import the data that were suggested in
the subject.

This might be too restrictive, see the section of improvements for a
proposition of improvement.

The \verb!_setup! function will instanciate the \verb!data! attribute, that
will be sent to the simulation. We use the \verb!json! python package to import
the json file.

\paragraph{The CsvImporter class}

This class will do the same as the previous one, but for CSV files. We use the
\verb!csv! python package to import the file. The assumptions for this format
are the following:
\begin{itemize}
\item the first line contains the name of the sensors that are in the files
\item the next lines contain as a first value the timestamp when the data was
generated, and then the other data for each sensor (on the same column as the
name of the sensor in the first line)
\end{itemize}

These conditions are less restrictive than for the JSON format, but they are
still conditions and we can debate about how to remove them.

One tricky part is that the data in a CSV file is only plain text, (compared
to JSON where we know when a data is an integer or a string). To find what
is the type of the data, we try to cast it as an \verb!int!, if it fails
we try as a \verb!float! if it fails it will remain a \verb!string!. The
\verb!_setup! function will import the data, find the type of every element,
associate every measure to its sensor, sort by timestamp and put this in the
\verb!data! attribute, to be sent to the simulation.

\subsubsection{The AggregatedSensor class}

This class is one of the most important, as it will allow to group
sensors. The aggregated sensor will work as if it was a single sensor (only one
method \verb!_popNext!), and it will choose among the different sensors
that it contains what is the one that will generate data the soonest
(and will return this one). The only method used by the user is the method
\verb!addSensors! that will add many sensors to the aggregated sensor.

It also allows to build complex sensors. For example, the multiplication of one
sensor by an integer will return an aggregated sensor with multiple occurences
of the sensor.By default, Python sends references of objects, so we must make
sure to use \verb!deepcopy! of sensors, to send new objects. Adding two sensors
will also create an aggregated sensor containing the two sensors.

\subsection{Display}

The display is the third big block of the whole simulation. It will output data
on different possible outputs. Currently, two types of output are implemented:
display to an influxDB database, and to a file in JSON format.

\subsubsection{The Display abstract class}

This interface contains the methods \verb!addPlot!, \verb!_setup! and
\verb!end!. The method addPlot will add a data in the output. The method end
will be called by the simulation when there is no more data to send; this is
used by displays in files, because we don't want to open and close the file
each time we add a data in the file. To do this, we just open the file at the
end of the simulation, write everything, and close right after.

\subsubsection{Display to an influxDB database}

In order to visualize data with Grafana, we must send data to an influxDB data
base. Because this database is accessible with POSTÂ requests at a given url, we
simply use the \verb!requests! package to send custom requests to an url.

This way, during setup, we send a request to delete previous databases, create
the new one. And when the simulation generates a Data, we send the adapted POST
request to the server. If the user wants to plot this data in Grafana, simply
plot influxDB data the regular way.

\subsubsection{Display to a file in JSON format}

The \verb!Data! class gives a way to export a data in a dictionary. The class JsonDisplay will store in a list all the data it receive, and at the call of the \verb!_end! it will store it in the file selected.

The output file will contain the name of the database, the base time (time when the simulation was done), the unit of the time, and then the list of data.


\subsection{Generator}

They are like sensors in construction. They gather objects and information, and
when calling the \verb!build()! function, they output the sensor adapted to the
given informations.

We implemented two Generators, but it is easy to build new ones (see possible
extensions section) :
\begin{itemize}
    \item \verb!Interpolator! : builds a polynomial sensor from a set of points.
    \item \verb!MultipleSensor! : builds an Aggregated Sensor containing
multiple copies of a sensor. We must be careful because Python sends references
by default, so we had to overload all \verb!__deepcopy__! operations to make
sure that \verb!sensor * 10! builds 10 different sensors, and not 10 references
to the same object
\end{itemize}
