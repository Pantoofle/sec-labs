
In this section, we will present how we implemented everything. The
presentation will be done class by class. All the functions that are
prefixed by an underscore should never be used by the user (for example
\_popNext). These functions are auxilliary functions that are used by the
simulation to generate the data. This convention follows the PEP8 convention of
python, as python does not give a way to protect methods.

\subsection{Sensors}

The main class that need to be understood first is the class of the
sensors. The idea is to have sensors defined by different manners that will
behave the same way. For example, from the simulation class, it will be
impossible to know if a data comes from data imported from a file, or from
a Markov Chain. The Sensor class is an abstract class that will define the
functions that need to be implemented in order to get this behaviour.

\subsubsection{The Sensor abstract class}

The main implementation choice that was made was the one to know how we would
generate the data, and send it to the simulation. This is done using a method
\verb!_popNext! that will return the next data generated by the sensor. The
associated function is \verb!_getNext! that will return the next data that will
be generated, but this data is not meant to be used right now (the data can be
used to know beforehand when will be the next data generated).

Each sensor must also implement a \verb!_advanceTime! function, called after a
\verb!_popNext!, this moves the sensor inner clock to the next data that will
be returned

Above that, a sensor has a \verb!name! attribute, with the associated setter
(\verb!setName!). If the name is not defined by the user, it will be generated
automatically as ``Sensor\_i'' where $i$ will be incremented each time a new
name is defined (to prevent from two sensors with the same name).

Now we should look deeper into the different classes that will inherit from the
Sensor class

\subsubsection{The Importer abstract class}

The importer class is also an abstract class that implements the function
to read text from an input file. The user has to define a filename at the
creation of the class. The real importation of the data (depending on the type
of storage of the data) is done in inherited classes.

\paragraph{The JsonImporter class}




\subsubsection{The modelSensor abstract class}

This class is an abstract class that represents a sensor modelled by some
law. For example, the user may want to define a sensor that will behave like a
Markov Chain, or a like a given function. The inherited class will represent a
different model. There is an attribute defined by the modelSensor class that is
the step of the created sensor. The step attribute will define at which speed
the sensor will send data (for example, a computer energy consumption can be
received each millisecond, whereas sensor from a parking lot will only send
data every second, or minute).

\paragraph{Markov Chains}

One model that is implemented is the one of Markov Chains. The state returned
by the sensor is following the low of a Markov Chain. To define a Markov
Chain, the user need to define the nodes, the transitions and the starting
node. Adding nodes and setting the starting node is easy, the nodes are the
values that will be returned by the sensor: for example, if the nodes are
integers (modelling the wealth of someone) it will be possible to show it
on a graph; the nodes can also be strings (modelling the weather: ``sunny'',
``rainy'', ``snowy'') and then, it will be harder to show the data on a graph.

Setting the transition is harder: the implementation choosed to give a method
\verb!addTransition(node1, node2, proba)!. The user has to define all the
values of the transitions (the initial probability is 0).

The Markov Chains come with a big issue that are the fact that we use
probabilities. The next state of the MC is a random variable, that need to
follow a distribution (where the sum of the probabilities is equal to 1). If
the user doesn't specify well the probability of the transitions, this can lead
to bugs. The solution that was done was to enforce that the last node have
probability equal to one minus the sum of the other probabilities. This way,
even if the user enters an illegal probability distribution, the simulation
will work.
This was also done because as we are working with probabilities, we work
with floating points. The issue with floating points is that some errors of
roundings can occur, even if the user entered a legitimate distribution (for
example [0.01, 0.01, ..., 0.01] that are not dyadic numbers). This is very
unlikely to happen, but it is possible

\paragraph{FunctionSensor class}

This class will also behave like a sensor, but will generate data from a given
function. The function is an attribute of the instance of the class, and there
is the setter associated to it.

\subparagraph{Polynomial sensor}

A special type of FunctionSensor. It implements a polynomial function of
the time. It can be built from a polynomial, a set of coefficients or a set
of points from which we interpolate the polynomial. See previous section for
useage.

\paragraph{Masked Sensor}

A Wrapper around a sensor. Calls the sub-sensor, but forwards its data only if
the timestamp is in in a valid segment.

\paragraph{Speed Sensor}

A Wrapper around a sensor. Calls the sub-sensor, and scales the timestamp of
the returned data. This way, it acts as if the sub-sensor runds at a different
speed.

\paragraph{Aggregated Sensor}

Contains multiple sensors, and gives a single interface to get all
points of data.  When its \verb!_getNext! function is called, it will call
\verb!_getNext! on all of its sensors, and see which sensor will be the first
to return data. When calling \verb!_popNext!, it pops only the first data
that should be returned. This way, we allow multiple data returned at the same
timestamp.

The inner time of this wrapper is the lowest time of all of its sensors.

\subsection{Display}

The display is the third big block of the whole simulation. It will output data
on different possible outputs. Currently, two types of output are implemented:
display to an influxDB database, and to a file in JSON format.

\subsubsection{The Display abstract class}

This class is really here to define the interface that will be used
by the simulation. This interface contains the methods \verb!addPlot!,
\verb!_setup! and \verb!end!. The method addPlot will add a data in the
output. The method end will be called by the simulation when there is no more
data to send; this is used by displays in files, because we don't want to open
and close the file each time we add a data in the file. To do this, we just
open the file at the end of the simulation, write everything, and close right
after.

\subsubsection{Display to an influxDB database}

\subsubsection{Display to a file in JSON format}
