
<<<<<<< HEAD
In this section, we will present how we implemented everything. The presentation will be done class by class. All the functions that are prefixed by an underscore should never be used by the user (for example \verb!_popNext! or \verb!_setup!). These functions are auxilliary functions that are used by the simulation to generate the data. This convention follows the PEP8 convention of python, as python does not give a way to protect methods.

\subsection{Timestamp}

\noteMathieu{TODO Simon}


\subsection{Data}

\noteMathieu{TODO Mathieu / Simon}


\subsection{Simulation}

\noteMathieu{TODO Mathieu / Simon}

\subsection{Sensors}

The main class that need to be understood first is the class of the
sensors. The idea is to have sensors defined by different manners that will
behave the same way. For example, from the simulation class, it will be
impossible to know if a data comes from data imported from a file, or from
a Markov Chain. The Sensor class is an abstract class that will define the
functions that need to be implemented in order to get this behaviour.

\subsubsection{The Sensor abstract class}

The main implementation choice that was made was the one to know how we would
generate the data, and send it to the simulation. This is done using a method
\verb!_popNext! that will return the next data generated by the sensor. The
associated function is \verb!_getNext! that will return the next data that will
be generated, but this data is not meant to be used right now (the data can be
used to know beforehand when will be the next data generated).
>>>>>>> 3c8ef2eae5fb9f7d65dd5d6ce4b7e8c08bfff7c6

Each sensor must also implement a \verb!_advanceTime! function, called after a
\verb!_popNext!, this moves the sensor inner clock to the next data that will
be returned

Above that, a sensor has a \verb!name! attribute, with the associated setter
(\verb!setName!). If the name is not defined by the user, it will be generated
automatically as ``Sensor\_i'' where $i$ will be incremented each time a new
name is defined (to prevent from two sensors with the same name).

Now we should look deeper into the different classes that will inherit from the
Sensor class

<<<<<<< HEAD
=======
\subsubsection{The Importer abstract class}

The importer class is also an abstract class that implements the function
to read text from an input file. The user has to define a filename at the
creation of the class. The real importation of the data (depending on the type
of storage of the data) is done in inherited classes.

\paragraph{The JsonImporter class}



>>>>>>> 3c8ef2eae5fb9f7d65dd5d6ce4b7e8c08bfff7c6

\subsubsection{The modelSensor abstract class}

This class is an abstract class that represents a sensor modelled by some
law. For example, the user may want to define a sensor that will behave like a
Markov Chain, or a like a given function. The inherited class will represent a
different model. There is an attribute defined by the modelSensor class that is
the step of the created sensor. The step attribute will define at which speed
the sensor will send data (for example, a computer energy consumption can be
received each millisecond, whereas sensor from a parking lot will only send
data every second, or minute).

\paragraph{Markov Chains}

One model that is implemented is the one of Markov Chains. The state returned
by the sensor is following the low of a Markov Chain. To define a Markov
Chain, the user need to define the nodes, the transitions and the starting
node. Adding nodes and setting the starting node is easy, the nodes are the
values that will be returned by the sensor: for example, if the nodes are
integers (modelling the wealth of someone) it will be possible to show it
on a graph; the nodes can also be strings (modelling the weather: ``sunny'',
``rainy'', ``snowy'') and then, it will be harder to show the data on a graph.

Setting the transition is harder: the implementation choosed to give a method
\verb!addTransition(node1, node2, proba)!. The user has to define all the
values of the transitions (the initial probability is 0).

The Markov Chains come with a big issue that are the fact that we use
probabilities. The next state of the MC is a random variable, that need to
follow a distribution (where the sum of the probabilities is equal to 1). If
the user doesn't specify well the probability of the transitions, this can lead
to bugs. The solution that was done was to enforce that the last node have
probability equal to one minus the sum of the other probabilities. This way,
even if the user enters an illegal probability distribution, the simulation
will work.
This was also done because as we are working with probabilities, we work
with floating points. The issue with floating points is that some errors of
roundings can occur, even if the user entered a legitimate distribution (for
example [0.01, 0.01, ..., 0.01] that are not dyadic numbers). This is very
unlikely to happen, but it is possible

\paragraph{FunctionSensor class}

This class will also behave like a sensor, but will generate data from a given
function. The function is an attribute of the instance of the class, and there
is the setter associated to it.

\subparagraph{Polynomial sensor}

A special type of FunctionSensor. It implements a polynomial function of
the time. It can be built from a polynomial, a set of coefficients or a set
of points from which we interpolate the polynomial. See previous section for
useage.
>>>>>>> 3c8ef2eae5fb9f7d65dd5d6ce4b7e8c08bfff7c6

\paragraph{Masked Sensor}

A Wrapper around a sensor. Calls the sub-sensor, but forwards its data only if
the timestamp is in in a valid segment.

\paragraph{Speed Sensor}

A Wrapper around a sensor. Calls the sub-sensor, and scales the timestamp of
the returned data. This way, it acts as if the sub-sensor runds at a different
speed.

\paragraph{Aggregated Sensor}

Contains multiple sensors, and gives a single interface to get all
points of data.  When its \verb!_getNext! function is called, it will call
\verb!_getNext! on all of its sensors, and see which sensor will be the first
to return data. When calling \verb!_popNext!, it pops only the first data
that should be returned. This way, we allow multiple data returned at the same
timestamp.

The inner time of this wrapper is the lowest time of all of its sensors.


\subsubsection{The Importer abstract class}

The importer class is also an abstract class that implements the function to read text from an input file, and the functions to get the next data (\verb!_popNext! and \verb!_getNext!). The user have to define a filename at the creation of the class. The real importation of the data (depending on the type of storage of the data) is done in inherited classes, during the setup phase. During this phase, the inherited classes will have to store the data in the attribute \verb!data!, in a \verb!deque! \noteMathieu{Expliquer cela}, where the timestamps are sorted in increasing order. Then the methods \verb!_popNext! and \verb!_getNext! will do the interface with the simulation (by popping data from the \verb!deque!).

\paragraph{The JsonImporter class}

To import a JSON file, we need to know what will be the attributes of the main dictionnary. I use \url{https://github.com/SINTEF-9012/sensapp/tree/master/net.modelbased.sensapp.data.samples/CyclingData}[this format], as it is suggested in the subject of the project. We suppose that:
\begin{itemize}
\item the main data is a dictionary
\item there is a key \verb!"bn"! and the value is the name of the sensor
\item there is a key \verb!"e"! and the value is the data, as a list of dictionaries, one for each data
\item each data is a dictionary with:
      \begin{itemize}
      \item a key \verb!"t"! and the value is the timestamp
      \item a key \verb!"v"! and the value is the data of the sensor
      \end{itemize}
\end{itemize}

This assumptions are done to be able to import the data that were suggested in the subject.

This might be too restrictive, see section \ref{improvement_jsonimporter} for a proposition of improvement.

The \verb!_setup! function will instanciate the \verb!data! attribute, that will be sent to the simulation. We use the \verb!json! python package to import the json file.

\paragraph{The CsvImporter class}

This class will do the same as the previous one, but for CSV files. We use the \verb!csv! python package to import the file. The assumptions for this format are the following:
\begin{itemize}
\item the first line contains the name of the sensors that are in the files
\item the next lines contain as a first value the timestamp when the data was generated, and then the other data for each sensor (on the same column as the name of the sensor in the first line)
\end{itemize}

These conditions are less restrictive than for the JSON format, but they are still conditions and we can debate about how to remove them.

One tricky part is that the data in a CSV file is only plain text, (compared to JSON where we know when a data is an integer or a string). To find what is the type of the data, we try to cast it as an \verb!int!, if it fails we try as a \verb!float! if it fails it will remain a \verb!string!. The \verb!_setup! function will import the data, find the type of every element, associate every measure to its sensor, sort by timestamp and put this in the \verb!data! attribute, to be sent to the simulation.



\subsubsection{The AggregatedSensor class}

This class is one of the most important, as it will allow to group sensors. When defining sensors, the user might want to group them (for example all the sensors of one office), because we don't want to define by hand all the sensors of an office each time we want to define one. What the user can now do is to say : my school is composed of 4 floors, each floor is composed of 20 offices, each office have a temperature sensor, a light sensor, ...

The aggregated sensor will work as if it was a single sensor (only one method \verb!_popNext!), and it will choose among the different sensors that it contains what is the one that will generate a data the soonest (and will return this one). The only method used by the user is the method \verb!addSensors! that will add many sensors to the aggregated sensor.

Also, this is this sensor that will be generated by operation on sensors. A multiplication of one sensor by an integer will return an aggregated sensor with the good number of occurences of the original sensor. By doing that, we need to be careful about the fact that we need to copy the sensor, and not give it as a reference (this is done automatically). Adding two sensors will also create an aggregated sensor containing the two sensors.


\subsection{Display}

The display is the third big block of the whole simulation. It will output data
on different possible outputs. Currently, two types of output are implemented:
display to an influxDB database, and to a file in JSON format.

\subsubsection{The Display abstract class}

This class is really here to define the interface that will be used
by the simulation. This interface contains the methods \verb!addPlot!,
\verb!_setup! and \verb!end!. The method addPlot will add a data in the
output. The method end will be called by the simulation when there is no more
data to send; this is used by displays in files, because we don't want to open
and close the file each time we add a data in the file. To do this, we just
open the file at the end of the simulation, write everything, and close right
after.

\subsubsection{Display to an influxDB database}

\noteMathieu{TODO Simon}

\subsubsection{Display to a file in JSON format}

\noteMathieu{TODO Mathieu}


\subsection{Generator}

\noteMathieu{TODO Simon}
